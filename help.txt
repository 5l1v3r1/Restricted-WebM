Q&A:
~~~~

Q: When should I use the HQ mode?
A: In theory the choice is simple. Use standard mode if your primary goal is to fit the output webm into the file size limit, use HQ mode if you want better quality at the cost of a smaller resolution. However this choice becomes somewhat less obvious, once we start using low bitrates. VP8's 2-pass encoding delivers better results at high(er) bitrates, but at the lower end of the spectrum it becomes a wildcard. In my experience it tends to prioritize the wrong details (e.g. stuff in the background becomes more detailed, while facial features suffer a loss in quality) and has problems when there are both calm and hectic scenes in the same video, as it assigns too much bitrate to the hectic scenes (you might not even notice, when we're talking about fast movements) and leaves the calmer scenes with a lot of compression artifacts. Therefore, if you're not satisfied with the produced webm in HQ mode, try again with the standard mode, as it might lead to a better result.

Q: What should I do if I want a bigger minimum resolution?
A: Using the scale filter manually (via the -f flag) will deactivate automatic downscaling, so if you e.g. want a minimum height of 360p, but the output is smaller, then add "-f scale=-1:360" to your command.

Q: How can I disable the undershoot limit?
A: Use "-u 0" in your command.

Q: FFmpeg shows an error when using VP9/Opus instead of VP8/Vorbis ("Failed to set VP8E_SET_TUNING codec control: Invalid parameter. Additional information: Option --tune=ssim is not currently supported in VP9."). Should I be concerned?
A: I don't think so. Using SSIM instead of PSNR produces better results with VP8. Apparently VP9 doesn't support the tune option (even though it's listed as an option in libvpx-vp9's documentation), but there aren't any consequences. FFmpeg simply ignores the option.

Q: Why does the script pause at the beginning, when I scale manually?
A: If you use the scale filter manually, then the script makes a test encode of the input video with your custom scale settings. Although it's just a second long and utilizes the fastest encoding setting, there might be a few seconds long delay depending on how big the resolution and/or how powerful your PC is.


How it works:  
~~~~~~~~~~~~~

	Standard mode:

		1. Chooses audio bitrate based on video length and file size limit.
		2. Calculates video bitrate based on video length and file size limit.  
		3. Downscales the output to ensure a minimum bits per pixel value (>= 0.04 for normal, >=0.075 for HQ mode) is reached. Stops at 180p, even if bpp value is still too low. Automatic downscaling is disabled if the scale filter is used manually.  
		4. Reduces the frame rate if the bpp value is still below its threshold at the minimum resolution. Only affects input files with a frame rate above 24fps when automatic downscaling is active.  
		5. Encodes a webm with variable bitrate mode and a minimum crf value. Uses 2-pass encoding if bits per pixel value is high enough (>= 0.075) and a minimum video bitrate of 500kbps is used.  
		6. Adjusts encoding settings if the produced webm is larger than the specified limit or smaller than a certain percentage of the limit (default 75%).  
		7.1. (if too large) Loops through different video encoding settings (variable bitrate without minimum crf -> constant bitrate -> constant bitrate ) starting with the originally calculated bitrate and adjusting it i times (can be specified by user; default value is 2). Note: Since the minimum crf value produces a certain minimum file size, the script may skip ahead to the next bitrate mode to avoid useless encoding attempts.  
		7.2. (if too small) Adjusts bitrate to increase file size (doesn't loop through bitrate modes anymore). May lead to less downscaling and the original frame rate being restored. Saves the settings, for the best attempt of reaching the undershoot limit while staying within the file size limit and utilizes them, if unable to reach said file size range after 2*i iterations.
		8. (Optional, depending on the produced webms) Creates a list of files (too_large.txt and too_small_for_undershoot.txt) that cannot be fit into the file size / undershoot limit, even after going through all available steps.  

	Audio showcase mode:
	
		0. (if auto or manual option) Get image path automatically or from user
		1. Chooses audio bitrate based on video length and file size limit.
		2. Calculates theoretical video bitrate based on video length and file size limit.  
		3. Downscales output video based on the theoretical video bitrate.
		4. Sets frame rate to 1 fps, keyframe interval to 20 frames and the real video bitrate (the one being used for the actual conversion) to 10Mbps (will never be fully utilized; gives ffmpeg the freedom to use whatever bitrate is necessary to reach crf 10).
		5. Encodes a webm with variable bitrate mode and 2-pass encoding enabled (that's always the case).
		6. Increases keyframe interval if webm size is larger than the file size limit. Maximum number of attempts are i*2. Note that any undershoot limit will be ignored in this mode.
		7. (Optional, depending on the produced webms) Creates a list of files (too_large.txt) that cannot be fit into the file size limit.
	
	Note that animated gifs will follow the steps of the standard mode, even if you use the audio showcase mode.

	
Command line usage:
~~~~~~~~~~~~~~~~~~~

	Usage: convert.sh [-h] [-t] [-a] [-q] [-c { auto | manual | video }] [-n] [-s file_size_limit] [-u undershoot_limit] [-i iterations] [-f filters]
		-h: Show Help. For more detailed infos: Read help.txt.
		-t: Enable trim mode.
		-a: Enable audio encoding.
		-q: Enable HQ (high quality) mode. Doesn't work if you manually use the scale filter.
		-c { auto | manual | video }: Enable audio showcase mode. Supersedes -a, -u and -q flag.
			auto: Use images with matching filename in showcase_pictures.
			manual: Enter path to picture manually for each video.
			video: Apply settings to videos in to_convert.
		-n: Use the newer codecs VP9/Opus instead of VP8/Vorbis.
		-s file_size_limit: Specify the file size limit in MB. Default value is 3.
			4chan limits:
				/gif/ and /wsg/: 4MB - audio allowed - max. 300 seconds
				all other boards: 3MB - no audio allowed - max. 120 seconds
			8chan limits:
				all boards: 8MB - audio allowed
		-u undershoot_limit: Define what percentage of the file size limit must be utilized. Default value: 0.75 (75%).
		-i iterations: Define how many times the script tries to adjust the bitrate for each bitrate mode. Default value is 2.
		-f filters: Add custom ffmpeg filters. Refer to ffmpeg's documentation for further information.


Options in more detail:
~~~~~~~~~~~~~~~~~~~~~~~
	
	Trim mode:
	Lets you define which part of the input video to use. Input is required for each individual file, so if you want to convert a folder full of videos in one go, trim them beforehand. The start and end time must be specified in seconds (also works with fractions of a second). Start defaults to 0 seconds and end to the length of the input video, if the input line is left empty.

	Audio mode:
	Adds an audio stream to the output webm. Audio bitrate gets chosen automatically based on video length and file size limit. Current maximum for standard mode is 128kbps. I tried matching my experience with a 4MB limit, so there's still a lot of room for improvement.
	Audio mode is off by default, but gets used automatically while using the audio showcase mode, so there's no need for the -a flag, if you already have to -c flag set.

	HQ (high quality) mode:
	The goal of this mode is to raise the bits per pixel value high enough to utilize 2-pass encoding. Therefore it allows further downscaling and is more likely to result in a frame rate reduction. It's however no guarantee for 2-pass encoding. The audio bitrate is currently fixed at 96kbps (this should change in the future). As it stands right now this mode shouldn't be used with custom scaling (via the -f flag), as it prevents 2-pass encoding from being utilized. This mode also becomes obsolete if you use the audio showcase mode.

	Audio showcase mode:
	Produces webm files with a frame rate of 1fps and with a static image as video stream. This leads to an incredible small video stream size, so that we can put more emphasis on the audio bitrate (ranges from 96kbps to 192kbps in this mode). The three flavours of this mode define how to locate the necessary input images.
	-) auto: The script assumes that there is a picture, with matching filename, for every input audio file in to_convert, located in showcase_pictures. The extension doesn't matter, so you can use any image that your version of ffmpeg is able to handle. This is the best option if you want to convert many files in the background.
	-) manual: The script asks you for the location of the input picture for each individual file. Doesn't require attention when it comes to additional folder structure, but prevents continuous encoding.
	-) video: Instead of using an audio file and a picture, the script applies the usual showcase settings to input videos in to_convert. Use this if you already have a video with a static image as video stream (e.g. from YouTube). Any other video content will become a slide show.

	Newer Codecs:
	VP9/Opus are the successors of VP8/Vorbis and produce much better results, especially at low bitrates. If a website allows webms with those codecs and you don't mind longer encoding times, then go for them.

	File size limit:
	Not much to say here. While I have 4chan's limits in mind while writing this script, it works with any file size limit.

	Undershoot limit:
	The initial video bitrate calculation is no exact science and the final output size heavily depends on what footage the video is showing. The undershoot limit prevents the script from stopping / going to the next video, when it doesn't utilize a certain percentage of the given file size limit (default 75%). Can range from 0 (completely disabled) to 1 (has to be exactly the file size limit). Personally I often use 0.9, which works fine. I wouldn't go higher than 0.95 though, as it only leads to a lot more encoding attempts for a minimal gain.

	Iterations:
	The script cycles through 3 bitrate modes and during each bitrate mode it adjusts the bitrate several times. With the -i flag you can specify how many encoding attempts there will be for each bitrate mode. Additionally the script will make i*2 attempts (so by default 6) once it got a webm within the file size limit, but not above the undershoot limit.

	Filters:
	Here you can enter your usual ffmpeg filters. This string will be used directly in the ffmpeg command, so it'll throw an error if you make any mistakes in it. Note that using the scale filter will disable automatic downscaling, so if you want to force the input resolution (quality be damned), use the scale filter manually.